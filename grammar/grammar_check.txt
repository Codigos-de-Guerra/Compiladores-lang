%token IF ENDIF ELSE SWITCH CASE FOR LOOP RETURN STRUCT CONST BREAK CONTINUE READ WRITE EXIT WHEN FUNCTION INT REAL CHAR STR BOOL VOID PLUS MINUS TIMES DIV MOD ASSIGN ASSIGN_PLUS ASSIGN_MINUS ASSIGN_MULT ASSIGN_DIV ASSIGN_MOD EQUALS DIFF LT GT LEQ GEQ OR AND NOT TRUE FALSE NUMBER CHARACTER STRING LEFT_PAREN RIGHT_PAREN LEFT_BRACE RIGHT_BRACE LEFT_BRACKET RIGHT_BRACKET ID SEMICOLON QUESTION_MARK COLON DOT POINTER_VAL ARROW COMMA INCREMENT DECREMENT REFERENCE TERNARY
%% /* LL(1) */

program : stmts;
stmts : /*eps*/;
stmts : stmt stmts;
stmt : decl_func;
stmt : decl_struct;
stmt : cmd ;
all_decl_var : decl_var_prim;
all_decl_var : const_decl_var;
decl_var_prim : primitivos hashtagzeromais cochetezeromais ID;
assign_expr : ASSIGN expr;
assign_expr : assign_extra expr;
assign_expr : inc;
inc_expr : inc ID;
const_decl_var : CONST decl_var_prim;
decl_func : FUNCTION type ID LEFT_PAREN typedlpar RIGHT_PAREN block;
decl_struct : STRUCT ID block SEMICOLON;
block : LEFT_BRACE stmts RIGHT_BRACE;
typedlpar : /*eps*/;
typedlpar : parameter typedlparAfter;
typedlparAfter : /*eps*/ ;
typedlparAfter : COMMA parameter typedlparAfter;
parameter : type parameterAfter;
parameterAfter : ID;
parameterAfter : REFERENCE ID;
cmd : cmd_decl_var SEMICOLON;
cmd : inOut SEMICOLON;
cmd : cmd_loop;
cmd : cmd_cond;
cmd : cmd_switch;
cmd : expr_without_term SEMICOLON;
cmd : idAfterRule SEMICOLON;
cmd : RETURN expr SEMICOLON;
cmd : BREAK SEMICOLON;
cmd : CONTINUE SEMICOLON;
cmd : EXIT WHEN expr SEMICOLON;
cmd : block ;
idAfterRule : ID idAfterAfterRule ;
idAfterRule : inc ID ;
idAfterAfterRule : termAfter;
idAfterAfterRule : assign_expr;
idAfterAfterRule : ID hashtagzeromais cochetezeromais assign_expr_maybe;
cmd_decl_var : all_decl_var assign_expr_maybe;
assign_expr_maybe : /*eps*/;
assign_expr_maybe : assign_expr;
cmd_loop : for;
cmd_loop : loop;
cmd_cond : if;
cmd_switch : switch;
for : FOR LEFT_PAREN for_stmts SEMICOLON for_stmts SEMICOLON for_stmts RIGHT_PAREN cmd;
for_stmts : /*eps*/;
for_stmts : all_decl_var assign_expr;
for_stmts : idAfterRule;
loop : LOOP cmd;
if : IF LEFT_PAREN expr RIGHT_PAREN cmd ENDIF else;
else :  /*eps*/;
else : ELSE cmd;
switch : SWITCH LEFT_PAREN expr RIGHT_PAREN LEFT_BRACE casezeromais RIGHT_BRACE;
casezeromais : /*eps*/;
casezeromais : case casezeromais;
case : CASE literal COLON stmts;
funCall : LEFT_PAREN lpar RIGHT_PAREN;
lpar : expr lparAfter;
lparAfter :  /*eps*/;
lparAfter : COMMA expr lparAfter;
expr_tern : TERNARY expr QUESTION_MARK expr COLON expr;
op_un : NOT;
op_bin : op_math;
op_bin : op_logic;
op_math : MINUS;
op_math : PLUS;
op_math : DIV;
op_math : TIMES;
op_math : MOD;
assign_extra : ASSIGN_PLUS;
assign_extra : ASSIGN_MINUS;
assign_extra : ASSIGN_MULT;
assign_extra : ASSIGN_DIV;
assign_extra : ASSIGN_MOD;
op_logic : EQUALS;
op_logic : DIFF;
op_logic : LEQ ;
op_logic : GEQ ;
op_logic : GT ;
op_logic : LT ;
op_logic : AND;
op_logic : OR;
inc : DECREMENT;
inc : INCREMENT;
inOut : in;
inOut : out;
in : READ LEFT_PAREN ID RIGHT_PAREN;
out : WRITE LEFT_PAREN ID RIGHT_PAREN;
type : typename hashtagzeromais cochetezeromais;
typename : primitivos;
typename : ID;
primitivos : INT;
primitivos : REAL;
primitivos : CHAR;
primitivos : BOOL;
primitivos : STR;
primitivos : VOID;
hashtagzeromais : /*eps*/;
hashtagzeromais : POINTER_VAL hashtagzeromais ;
literal : NUMBER;
literal : CHARACTER;
literal : TRUE;
literal : FALSE;
literal : STRING;
array_access : LEFT_BRACKET expr RIGHT_BRACKET cochetezeromais;
cochetezeromais : /*eps*/;
cochetezeromais : LEFT_BRACKET expr RIGHT_BRACKET cochetezeromais  ;
termAfter : array_access;
termAfter : ponteirozeromais;
termAfter : funCall;
ponteirozeromais : /*eps*/;
ponteirozeromais : ARROW ID ponteirozeromais;
expr : op_un expr;
expr : LEFT_PAREN expr RIGHT_PAREN;
expr : ID termAfter expr_binMaybe;
expr : expr_tern;
expr : literal;
expr : /*eps*/;
expr_without_term :  op_un expr;
expr_without_term : LEFT_PAREN expr RIGHT_PAREN;
expr_without_term : expr_tern;
expr_without_term : literal;
expr_without_term : /*eps*/;
expr_binMaybe : /*eps*/;
expr_binMaybe : op_bin expr;

program : stmts {};
stmts : /*epsilon*/ {}
      | stmt stmts {}
stmt : decl_func {}
      | decl_struct {}
      | cmd {};
all_decl_var : decl_var_prim {}
            | const_decl_var {};
decl_var_prim : primitivos hashtagzeromais cochetezeromais ID {};
assign_expr : ASSIGN expr {}
            | assign_extra expr {}
            | inc {};
inc_expr : inc ID {};
const_decl_var : CONST decl_var_prim {};
decl_func : FUNCTION type ID LEFT_PAREN typedlpar RIGHT_PAREN block {};
decl_struct : STRUCT ID block SEMICOLON {};
block : LEFT_BRACE stmts RIGHT_BRACE {};
typedlpar : /*epsilon*/ {}
      | parameter typedlparAfter {}
typedlparAfter : /*epsilon*/ {}
      | COMMA parameter typedlparAfter {};
parameter : type parameterAfter {};
parameterAfter : ID {}
      | REFERENCE ID {};
cmd : cmd_decl_var SEMICOLON {}
      | inOut SEMICOLON {}
      | cmd_loop {}
      | cmd_cond {}
      | cmd_switch {}
      | expr_without_term SEMICOLON {}
      | idAfterRule SEMICOLON {}
      | RETURN expr SEMICOLON {}
      | BREAK SEMICOLON {}
      | CONTINUE SEMICOLON {}
      | EXIT WHEN expr SEMICOLON {}
      | block {};
idAfterRule : ID termAfter idAfterAfterRule {}
      | inc ID cochetezeromais {}
      | expr_binMaybe {};
idAfterAfterRule : assign_expr {}
      | ID hashtagzeromais cochetezeromais assign_expr_maybe {};
cmd_decl_var : all_decl_var assign_expr_maybe {};
assign_expr_maybe : /*epsilon*/ {}
      | assign_expr {};
cmd_loop : for {}
      | loop {}
cmd_cond : if {};
cmd_switch : switch {};
for : FOR LEFT_PAREN for_stmt SEMICOLON for_stmt SEMICOLON for_stmt RIGHT_PAREN cmd {};
for_stmt : /*epsilon*/ {}
      | all_decl_var assign_expr {}
      | idAfterRule {};
loop : LOOP cmd {};
if : IF LEFT_PAREN expr RIGHT_PAREN cmd ENDIF else {};
else :  /*epsilon*/ {}
      | ELSE cmd {};
switch : SWITCH LEFT_PAREN expr RIGHT_PAREN LEFT_BRACE casezeromais RIGHT_BRACE {};
casezeromais : /*epsilon*/ {}
      | case casezeromais {};
case : CASE literal COLON stmts {};
funCall : LEFT_PAREN lpar RIGHT_PAREN {};
lpar : expr lparAfter {};
lparAfter :  /*epsilon*/ {}
      | COMMA expr lparAfter {};
expr_tern : TERNARY expr QUESTION_MARK expr COLON expr {};
op_un : NOT {};
op_bin : op_math {}
      | op_logic {}
op_math: MINUS {}
      | PLUS {}
      | DIV {}
      | TIMES {}
      | MOD {};
assign_extra : ASSIGN_PLUS {}
      | ASSIGN_MINUS {}
      | ASSIGN_MULT {}
      | ASSIGN_DIV {}
      | ASSIGN_MOD {};
op_logic : EQUALS {}
      | DIFF {}
      | LEQ {}
      | GEQ {}
      | GT {}
      | LT {}
      | AND {}
      | OR {};
inc : DECREMENT {}
      | INCREMENT {};
inOut : in {}
      | out {};
in : READ LEFT_PAREN ID RIGHT_PAREN {};
out : WRITE LEFT_PAREN ID RIGHT_PAREN {};
type : typename hashtagzeromais cochetezeromais {};
typename : primitivos {}
      | ID {};
primitivos : INT {}
      | REAL {}
      | CHAR {}
      | BOOL {}
      | STR {}
      | VOID {};
hashtagzeromais : /*epsilon*/ {}
      | POINTER_VAL hashtagzeromais {};
literal : NUMBER {}
      | CHARACTER {}
      | TRUE {}
      | FALSE {}
      | STRING {};
cochetezeromais : /*epsilon*/ {}
      | LEFT_BRACKET inside_cochete RIGHT_BRACKET cochetezeromais {};
inside_cochete : idAfterRule {}
      | expr {};
termAfter : cochetezeromais {}
      | ponteirozeromais {}
      | funCall {};
ponteirozeromais : /*epsilon*/ {}
      | ARROW ID ponteirozeromais {};
expr : op_un expr {}
      | LEFT_PAREN expr RIGHT_PAREN {}
      | ID termAfter expr_binMaybe {}
      | expr_tern {}
      | literal expr_binMaybe {}
      | /*epsilon*/ {};
expr_binMaybe : /*epsilon*/ {}
      | op_bin expr {};

expr_without_term : op_un expr {}
                | LEFT_PAREN expr RIGHT_PAREN {}
                | expr_tern {}
                | literal {}
                | /*epsilon*/ {};
